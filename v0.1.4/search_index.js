var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumControlTestUtils","category":"page"},{"location":"#QuantumControlTestUtils","page":"Home","title":"QuantumControlTestUtils","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nusing Pkg\n\nVERSION = Pkg.dependencies()[Base.UUID(\"d3fd27c9-1dfb-4e67-b0c0-90d0d87a1e48\")].version\n\ngithub_badge = \"[![Github](https://img.shields.io/badge/JuliaQuantumControl-QuantumControlTestUtils.jl-blue.svg?logo=github)](https://github.com/JuliaQuantumControl/QuantumControlTestUtils.jl)\"\n\nversion_badge = \"![v$VERSION](https://img.shields.io/badge/version-v$VERSION-green.svg)\"\n\nMarkdown.parse(\"$github_badge $version_badge\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The QuantumControlTestUtils package collects methods that are used for testing and benchmarking within the JuliaQuantumControl organization","category":"page"},{"location":"#Exported-Functions","page":"Home","title":"Exported Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [QuantumControlTestUtils, QuantumControlTestUtils.RandomObjects, QuantumControlTestUtils.DummyOptimization]\nPrivate = false","category":"page"},{"location":"#QuantumControlTestUtils.generate_coverage_html","page":"Home","title":"QuantumControlTestUtils.generate_coverage_html","text":"Generate an HTML report for existing coverage data.\n\ngenerate_coverage_html(path=\"./\"; covdir=\"coverage\", genhtml=\"genhtml\")\n\ncreates a folder covdir and use the external genhtml program to write an HTML coverage report into that folder.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumControlTestUtils.show_coverage","page":"Home","title":"QuantumControlTestUtils.show_coverage","text":"Print out a coverage summary from existing coverage data.\n\nshow_coverage(path=\"./src\"; sort_by=nothing)\n\nprints a a table showing the tracked files in path, the total number of tracked lines in that file (\"Total\"), the number of lines with coverage (\"Hit\"), the number of lines without coverage (\"Missed\") and the \"Coverage\" as a percentage.\n\nThe coverage data is collected from .cov files in path.\n\nOptionally, the table can be sorted by passing the name of a column to sort_by, e..g. sort_py=:Missed.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumControlTestUtils.test","page":"Home","title":"QuantumControlTestUtils.test","text":"Run a package test-suite in a subprocess.\n\ntest(\n    file=\"test/runtests.jl\";\n    root=pwd(),\n    project=\"test\",\n    code_coverage=\"user\",\n    show_coverage=(code_coverage == \"user\"),\n    color=<inherit>,\n    compiled_modules=<inherit>,\n    startup_file=<inherit>,\n    depwarn=<inherit>,\n    inline=<inherit>,\n    check_bounds=\"yes\",\n    track_allocation=<inherit>,\n    threads=<inherit>,\n    genhtml=false,\n    covdir=\"coverage\"\n)\n\nruns the test suite of the package located at root by running include(file) inside a new julia process.\n\nThis is similar to what Pkg.test() does, but differs in the \"sandboxing\" approach. While Pkg.test() creates a new temporary sandboxed environment, test() uses an existing environment in project (the test subfolder by default). This allows testing against the dev-versions of other packages. It requires that the test folder contains both a Project.toml and a Manifest.toml file.\n\nThe test() function also differs from directly including test/runtests.jl in the REPL in that it can generate coverage data and reports (this is only possible when running tests in a subprocess).\n\nIf show_coverage is passed as true (default), a coverage summary is shown. Further, if genhtml is true, a full HTML coverage report will be generated in covdir (relative to root). This requires the genhtml executable (part of the lcov package). Instead of true, it is also possible to pass the path to the genhtml exectuable.\n\nAll other keyword arguments correspond to the respective command line flag for the julia executable that is run as the subprocess.\n\nThis function is intended to be exposed in a project's development-REPL.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumControlTestUtils.RandomObjects.random_dynamic_generator-Tuple{Any, Any}","page":"Home","title":"QuantumControlTestUtils.RandomObjects.random_dynamic_generator","text":"Construct a random dynamic generator (time-dependent Hamiltonian).\n\ntlist = collection(range(0, 100, length=1001))\nĤ = random_dynamic_generator(N, tlist; kwargs...)\n\nby default initializes Ĥ as a real Hermitian Generator of dimension N. The generator consists of one random drift term and one random control term with a random control amplitude value ∈ [-1, 1] for each interval of the given tlist. The spectral envelope of the generator will be 1.0. That is, the largest absolute eigenvalue at any point in time should be less than 1.0. The larger N, the more tightly the envelope will fit.\n\nKeyword arguments\n\nnumber_of_controls=1: The number of control terms in the generator.\ndensity=1.0: A number > 0.0 and ≤ 1.0. Any value < 1.0 implies a sparse matrix where density is the approximate fraction of non-zero elements to total elements\ncomplex=false: Whether the matrix should be real-valued (default) or complex-valued\nhermitian=false: Whether the matrix should be Hermitian (have real eigenvalues, default) or non-Hermitian (eigenvalues in the complex plane with a circle of the spectral_envelope)\nspectral_envelope=1.0: An upper bound for the spectral radius for the generator evaluated at different points in time. For large N, the spectral envelope should be approximately touched for the extremal pulse amplitudes, ±1. Note that the average spectral radius is always well withing the spectral_envelope`)\nexact_spectral_envelope=false: If true, the spectral radius when plugging in the extremal pulse amplitudes ±1 will touch exactly the specified spectral_envelope. This is done via diagonalization, so it is only feasible for moderately large dimensions N.\nrng=Random.GLOBAL_RNG: The random number generator to use. The call Random.rand(rng, N, N) must produces a real-valued NN matrix with elements uniformly distributed between 0 and 1\n\nSee also\n\nrandom_matrix — generate a static random Hamiltonian\n\n\n\n\n\n","category":"method"},{"location":"#QuantumControlTestUtils.RandomObjects.random_matrix-Tuple{Any}","page":"Home","title":"QuantumControlTestUtils.RandomObjects.random_matrix","text":"Construct a random matrix.\n\nĤ = random_matrix(N; kwargs...)\n\nby default initializes Ĥ as a general complex NN matrix with a spectral radius of approximately 1.0. Keyword arguments allow to initialize real or complex, Hermitian or non-Hermitian, dense or sparse matrices with arbitrary spectral radius. The non-zero entries in Ĥ will be uniformly distributed around zero, with a range of values that depends on N and the desired spectral radius.\n\nKeyword arguments\n\ndensity=1.0: A number > 0.0 and ≤ 1.0. Any value < 1.0 implies a sparse matrix where density is the approximate fraction of non-zero elements to total elements\ncomplex=true: Whether the matrix should be complex-valued (default) or real-valued\nhermitian=false: Whether the matrix should be general (default) or Hermitian (real eigenvalues)\nspectral_radius=1.0: The approximate spectral radius, i.e. maximum absolute eigenvalue. This is according to Girko-Ginibri's circular law, in the limit of large N\nexact_spectral_radius=false: If given as true, ensure that the spectral_radius is exact. This is done via diagonalization, so it is only feasible for moderately large dimensions N. On the other hand, for large N, the spectral_radius, respectively the circular law becomes more exact anyway.\nrng=Random.GLOBAL_RNG: The random number generator to use. The call Random.rand(rng, N, N) must produces a real-valued NN matrix with elements uniformly distributed between 0 and 1\n\nSee also\n\nrandom_dynamic_generator — generate a time-dependent random\n\nHamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumControlTestUtils.RandomObjects.random_state_vector-Tuple{Any}","page":"Home","title":"QuantumControlTestUtils.RandomObjects.random_state_vector","text":"Return a random, normalized Hilbert space state vector of dimension N.\n\nrandom_state_vector(N; rng=GLOBAL_RNG)\n\n\n\n\n\n","category":"method"},{"location":"#QuantumControlTestUtils.DummyOptimization.dummy_control_problem-Tuple{}","page":"Home","title":"QuantumControlTestUtils.DummyOptimization.dummy_control_problem","text":"Set up a dummy control problem.\n\nproblem = dummy_control_problem(;\n    N=10, n_objectives=1, n_controls=1, n_steps=50, dt=1.0, density=0.5,\n    complex_operators=true, hermitian=true, pulses_as_controls=false, rng,\n    kwargs...)\n\nSets up a control problem with random (sparse) Hermitian matrices.\n\nArguments\n\nN: The dimension of the Hilbert space\nn_objectives: The number of objectives in the optimization. All objectives will have the same Hamiltonian, but random initial and target states.\nn_controls: The number of controls, that is, the number of control terms in the control Hamiltonian. Each control is an array of random values, normalized on the intervals of the time grid.\nn_steps: The number of time steps (intervals of the time grid)\ndt: The time step\ndensity: The density of the Hamiltonians, as a number between 0.0 and 1.0. For density=1.0, the Hamiltonians will be dense matrices.\ncomplex_operators: Whether or not the drift/control operators will be complex-valued or real-valued.\nhermitian: Whether or not all drift/control operators will be Hermitian matrices.\npulses_as_controls=false: If true, directly use pulses (discretized to the midpoints of the time grid) as controls, instead of the normal controls discretized to the points of the time grid.\nrng=Random.GLOBAL_RNG: The random number generator to use.  See random_matrix and random_state_vector.\nkwargs: All other keyword arguments are passed on to ControlProblem\n\n\n\n\n\n","category":"method"},{"location":"#QuantumControlTestUtils.DummyOptimization.optimize_with_dummy_method-Tuple{Any}","page":"Home","title":"QuantumControlTestUtils.DummyOptimization.optimize_with_dummy_method","text":"Run a dummy optimization.\n\nresult = optimize(problem, method=:dummymethod)\n\nruns through and \"optimization\" of the given problem where in each iteration, the amplitude of the guess pulses is diminished by 10%. The (summed) vector norm of the the control serves as the value of the optimization functional.\n\n\n\n\n\n","category":"method"}]
}
