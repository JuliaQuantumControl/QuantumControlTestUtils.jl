var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumControlTestUtils","category":"page"},{"location":"#QuantumControlTestUtils","page":"Home","title":"QuantumControlTestUtils","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The QuantumControlTestUtils package collects methods that are used for testing and benchmarking within the JuliaQuantumControl organization","category":"page"},{"location":"#Exported-Functions","page":"Home","title":"Exported Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [QuantumControlTestUtils, QuantumControlTestUtils.RandomObjects]\nPrivate = false","category":"page"},{"location":"#QuantumControlTestUtils.generate_coverage_html","page":"Home","title":"QuantumControlTestUtils.generate_coverage_html","text":"Generate an HTML report for existing coverage data.\n\ngenerate_coverage_html(path=\"./\"; covdir=\"coverage\", genhtml=\"genhtml\")\n\ncreates a folder covdir and use the external genhtml program to write an HTML coverage report into that folder.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumControlTestUtils.show_coverage","page":"Home","title":"QuantumControlTestUtils.show_coverage","text":"Print out a coverage summary from existing coverage data.\n\nshow_coverage(path=\"./src\"; sort_by=nothing)\n\nprints a a table showing the tracked files in path, the total number of tracked lines in that file (\"Total\"), the number of lines with coverage (\"Hit\"), the number of lines without coverage (\"Missed\") and the \"Coverage\" as a percentage.\n\nThe coverage data is collected from .cov files in path.\n\nOptionally, the table can be sorted by passing the name of a column to sort_by, e..g. sort_py=:Missed.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumControlTestUtils.test","page":"Home","title":"QuantumControlTestUtils.test","text":"Run a package test-suite in a subprocess.\n\ntest(\n    file=\"test/runtests.jl\";\n    root=pwd(),\n    project=\"test\",\n    code_coverage=\"user\",\n    show_coverage=(code_coverage == \"user\"),\n    color=<inherit>,\n    compiled_modules=<inherit>,\n    startup_file=<inherit>,\n    depwarn=<inherit>,\n    inline=<inherit>,\n    check_bounds=\"yes\",\n    track_allocation=<inherit>,\n    threads=<inherit>,\n    genhtml=false,\n    covdir=\"coverage\"\n)\n\nruns the test suite of the package located at root by running include(file) inside a new julia process.\n\nThis is similar to what Pkg.test() does, but differs in the \"sandboxing\" approach. While Pkg.test() creates a new temporary sandboxed environment, test() uses an existing environment in project (the test subfolder by default). This allows testing against the dev-versions of other packages. It requires that the test folder contains both a Project.toml and a Manifest.toml file.\n\nThe test() function also differs from directly including test/runtests.jl in the REPL in that it can generate coverage data and reports (this is only possible when running tests in a subprocess).\n\nIf show_coverage is passed as true (default), a coverage summary is shown. Further, if genhtml is true, a full HTML coverage report will be generated in covdir (relative to root). This requires the genhtml executable (part of the lcov package). Instead of true, it is also possible to pass the path to the genhtml exectuable.\n\nAll other keyword arguments correspond to the respective command line flag for the julia executable that is run as the subprocess.\n\nThis function is intended to be exposed in a project's development-REPL.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumControlTestUtils.RandomObjects.random_matrix-Tuple{Any}","page":"Home","title":"QuantumControlTestUtils.RandomObjects.random_matrix","text":"Construct a random matrix.\n\nĤ = random_matrix(N; kwargs...)\n\nby default initializes Ĥ as a general complex NN matrix with a spectral radius of approximately 1.0. Keyword arguments allow to initialize real or complex, Hermitian or non-Hermitian, dense or sparse matrices with arbitrary spectral radius. The non-zero entries in Ĥ will be uniformly distributed around zero, with a range of values that depends on N and the desired spectral radius.\n\nKeyword arguments\n\ndensity=1.0: A number > 0.0 and ≤ 1.0. Any value < 1.0 implies a sparse matrix where density is the approximate fraction of non-zero elements to total elements\ncomplex=true: Whether the matrix should be complex-valued (default) or real-valued\nhermitian=false: Whether the matrix should be general (default) or Hermitian (real eigenvalues)\nspectral_radius=1.0: The approximate spectral radius, i.e. maximum absolute eigenvalue. This is according to Girko-Ginibri's circular law, in the limit of large N\nrng=Random.GLOBAL_RNG: The random number generator to use. The call Random.rand(rng, N, N) must produces a real-valued NN matrix with elements uniformly distributed between 0 and 1\n\n\n\n\n\n","category":"method"},{"location":"#QuantumControlTestUtils.RandomObjects.random_state_vector-Tuple{Any}","page":"Home","title":"QuantumControlTestUtils.RandomObjects.random_state_vector","text":"Return a random, normalized Hilbert space state vector of dimension N.\n\nrandom_state_vector(N; rng=GLOBAL_RNG)\n\n\n\n\n\n","category":"method"}]
}
