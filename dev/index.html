<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · QuantumControlTestUtils.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://JuliaQuantumControl.github.io/QuantumControlTestUtils.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>QuantumControlTestUtils.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Exported-Functions"><span>Exported Functions</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQuantumControl/QuantumControlTestUtils.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QuantumControlTestUtils"><a class="docs-heading-anchor" href="#QuantumControlTestUtils">QuantumControlTestUtils</a><a id="QuantumControlTestUtils-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumControlTestUtils" title="Permalink"></a></h1><p><a href="https://github.com/JuliaQuantumControl/QuantumControlTestUtils.jl"><img src="https://img.shields.io/badge/JuliaQuantumControl-QuantumControlTestUtils.jl-blue.svg?logo=github" alt="Github"/></a> <img src="https://img.shields.io/badge/version-v0.1.4+dev-green.svg" alt="v0.1.4+dev"/></p><p>The <a href="https://github.com/JuliaQuantumControl/QuantumControlTestUtils.jl">QuantumControlTestUtils</a> package collects methods that are used for testing and benchmarking within the <a href="https://github.com/JuliaQuantumControl">JuliaQuantumControl</a> organization</p><h2 id="Exported-Functions"><a class="docs-heading-anchor" href="#Exported-Functions">Exported Functions</a><a id="Exported-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-Functions" title="Permalink"></a></h2><ul><li><a href="#QuantumControlTestUtils.DummyOptimization.dummy_control_problem-Tuple{}"><code>QuantumControlTestUtils.DummyOptimization.dummy_control_problem</code></a></li><li><a href="#QuantumControlTestUtils.DummyOptimization.optimize_with_dummy_method-Tuple{Any}"><code>QuantumControlTestUtils.DummyOptimization.optimize_with_dummy_method</code></a></li><li><a href="#QuantumControlTestUtils.RandomObjects.random_dynamic_generator-Tuple{Any, Any}"><code>QuantumControlTestUtils.RandomObjects.random_dynamic_generator</code></a></li><li><a href="#QuantumControlTestUtils.RandomObjects.random_matrix-Tuple{Any}"><code>QuantumControlTestUtils.RandomObjects.random_matrix</code></a></li><li><a href="#QuantumControlTestUtils.RandomObjects.random_state_vector-Tuple{Any}"><code>QuantumControlTestUtils.RandomObjects.random_state_vector</code></a></li><li><a href="#QuantumControlTestUtils.generate_coverage_html"><code>QuantumControlTestUtils.generate_coverage_html</code></a></li><li><a href="#QuantumControlTestUtils.show_coverage"><code>QuantumControlTestUtils.show_coverage</code></a></li><li><a href="#QuantumControlTestUtils.test"><code>QuantumControlTestUtils.test</code></a></li></ul><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumControlTestUtils.generate_coverage_html" href="#QuantumControlTestUtils.generate_coverage_html"><code>QuantumControlTestUtils.generate_coverage_html</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Generate an HTML report for existing coverage data.</p><pre><code class="language-julia hljs">generate_coverage_html(path=&quot;./&quot;; covdir=&quot;coverage&quot;, genhtml=&quot;genhtml&quot;)</code></pre><p>creates a folder <code>covdir</code> and use the external <code>genhtml</code> program to write an HTML coverage report into that folder.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlTestUtils.jl/blob/10524510f2ca7f2b26c219c4673538704fd13b1a/src/runner.jl#L97-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlTestUtils.show_coverage" href="#QuantumControlTestUtils.show_coverage"><code>QuantumControlTestUtils.show_coverage</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Print out a coverage summary from existing coverage data.</p><pre><code class="language-julia hljs">show_coverage(path=&quot;./src&quot;; sort_by=nothing)</code></pre><p>prints a a table showing the tracked files in <code>path</code>, the total number of tracked lines in that file (&quot;Total&quot;), the number of lines with coverage (&quot;Hit&quot;), the number of lines without coverage (&quot;Missed&quot;) and the &quot;Coverage&quot; as a percentage.</p><p>The coverage data is collected from <code>.cov</code> files in <code>path</code>.</p><p>Optionally, the table can be sorted by passing the name of a column to <code>sort_by</code>, e..g. <code>sort_py=:Missed</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlTestUtils.jl/blob/10524510f2ca7f2b26c219c4673538704fd13b1a/src/runner.jl#L23-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlTestUtils.test" href="#QuantumControlTestUtils.test"><code>QuantumControlTestUtils.test</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Run a package test-suite in a subprocess.</p><pre><code class="language-julia hljs">test(
    file=&quot;test/runtests.jl&quot;;
    root=pwd(),
    project=&quot;test&quot;,
    code_coverage=&quot;user&quot;,
    show_coverage=(code_coverage == &quot;user&quot;),
    color=&lt;inherit&gt;,
    compiled_modules=&lt;inherit&gt;,
    startup_file=&lt;inherit&gt;,
    depwarn=&lt;inherit&gt;,
    inline=&lt;inherit&gt;,
    check_bounds=&quot;yes&quot;,
    track_allocation=&lt;inherit&gt;,
    threads=&lt;inherit&gt;,
    genhtml=false,
    covdir=&quot;coverage&quot;
)</code></pre><p>runs the test suite of the package located at <code>root</code> by running <code>include(file)</code> inside a new julia process.</p><p>This is similar to what <code>Pkg.test()</code> does, but differs in the &quot;sandboxing&quot; approach. While <code>Pkg.test()</code> creates a new temporary sandboxed environment, <code>test()</code> uses an existing environment in <code>project</code> (the <code>test</code> subfolder by default). This allows testing against the dev-versions of other packages. It requires that the <code>test</code> folder contains both a <code>Project.toml</code> and a <code>Manifest.toml</code> file.</p><p>The <code>test()</code> function also differs from directly including <code>test/runtests.jl</code> in the REPL in that it can generate coverage data and reports (this is only possible when running tests in a subprocess).</p><p>If <code>show_coverage</code> is passed as <code>true</code> (default), a coverage summary is shown. Further, if <code>genhtml</code> is <code>true</code>, a full HTML coverage report will be generated in <code>covdir</code> (relative to <code>root</code>). This requires the <code>genhtml</code> executable (part of the <a href="http://ltp.sourceforge.net/coverage/lcov.php">lcov</a> package). Instead of <code>true</code>, it is also possible to pass the path to the <code>genhtml</code> exectuable.</p><p>All other keyword arguments correspond to the respective command line flag for the <code>julia</code> executable that is run as the subprocess.</p><p>This function is intended to be exposed in a project&#39;s development-REPL.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlTestUtils.jl/blob/10524510f2ca7f2b26c219c4673538704fd13b1a/src/runner.jl#L143-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlTestUtils.RandomObjects.random_dynamic_generator-Tuple{Any, Any}" href="#QuantumControlTestUtils.RandomObjects.random_dynamic_generator-Tuple{Any, Any}"><code>QuantumControlTestUtils.RandomObjects.random_dynamic_generator</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a random dynamic generator (time-dependent Hamiltonian).</p><pre><code class="language-julia hljs">tlist = collection(range(0, 100, length=1001))
Ĥ = random_dynamic_generator(N, tlist; kwargs...)</code></pre><p>by default initializes <code>Ĥ</code> as a real Hermitian <code>Generator</code> of dimension <code>N</code>. The generator consists of one random drift term and one random control term with a random control amplitude value ∈ [-1, 1] for each interval of the given <code>tlist</code>. The spectral envelope of the generator will be 1.0. That is, the largest absolute eigenvalue at any point in time should be less than 1.0. The larger <code>N</code>, the more tightly the envelope will fit.</p><p><strong>Keyword arguments</strong></p><ul><li><code>number_of_controls=1</code>: The number of control terms in the generator.</li><li><code>density=1.0</code>: A number &gt; 0.0 and ≤ 1.0. Any value &lt; 1.0 implies a sparse matrix where <code>density</code> is the approximate fraction of non-zero elements to total elements</li><li><code>complex=false</code>: Whether the matrix should be real-valued (default) or complex-valued</li><li><code>hermitian=false</code>: Whether the matrix should be Hermitian (have real eigenvalues, default) or non-Hermitian (eigenvalues in the complex plane with a circle of the <code>spectral_envelope</code>)</li><li><code>spectral_envelope=1.0</code>: An upper bound for the spectral radius for the generator evaluated at different points in time. For large <code>N</code>, the spectral envelope should be approximately touched for the extremal pulse amplitudes, ±1. Note that the <em>average</em> spectral radius is always well withing the spectral_envelope`)</li><li><code>exact_spectral_envelope=false</code>: If true, the spectral radius when plugging in the extremal pulse amplitudes ±1 will touch exactly the specified <code>spectral_envelope</code>. This is done via diagonalization, so it is only feasible for moderately large dimensions <code>N</code>.</li><li><code>rng=Random.GLOBAL_RNG</code>: The random number generator to use. The call <code>Random.rand(rng, N, N)</code> must produces a real-valued <span>$N×N$</span> matrix with elements uniformly distributed between 0 and 1</li></ul><p><strong>See also</strong></p><ul><li><a href="#QuantumControlTestUtils.RandomObjects.random_matrix-Tuple{Any}"><code>random_matrix</code></a> — generate a <em>static</em> random Hamiltonian</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlTestUtils.jl/blob/10524510f2ca7f2b26c219c4673538704fd13b1a/src/random.jl#L120-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlTestUtils.RandomObjects.random_matrix-Tuple{Any}" href="#QuantumControlTestUtils.RandomObjects.random_matrix-Tuple{Any}"><code>QuantumControlTestUtils.RandomObjects.random_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a random matrix.</p><pre><code class="language-julia hljs">Ĥ = random_matrix(N; kwargs...)</code></pre><p>by default initializes <code>Ĥ</code> as a general complex <span>$N×N$</span> matrix with a spectral radius of approximately 1.0. Keyword arguments allow to initialize real or complex, Hermitian or non-Hermitian, dense or sparse matrices with arbitrary spectral radius. The non-zero entries in Ĥ will be uniformly distributed around zero, with a range of values that depends on <code>N</code> and the desired spectral radius.</p><p><strong>Keyword arguments</strong></p><ul><li><code>density=1.0</code>: A number &gt; 0.0 and ≤ 1.0. Any value &lt; 1.0 implies a sparse matrix where <code>density</code> is the approximate fraction of non-zero elements to total elements</li><li><code>complex=true</code>: Whether the matrix should be complex-valued (default) or real-valued</li><li><code>hermitian=false</code>: Whether the matrix should be general (default) or Hermitian (real eigenvalues)</li><li><code>spectral_radius=1.0</code>: The approximate spectral radius, i.e. maximum absolute eigenvalue. This is according to <a href="https://www.johndcook.com/blog/2018/07/27/circular-law/">Girko-Ginibri&#39;s circular law</a>, in the limit of large <span>$N$</span></li><li><code>exact_spectral_radius=false</code>: If given as <code>true</code>, ensure that the <code>spectral_radius</code> is exact. This is done via diagonalization, so it is only feasible for moderately large dimensions <code>N</code>. On the other hand, for large <code>N</code>, the <code>spectral_radius</code>, respectively the circular law becomes more exact anyway.</li><li><code>rng=Random.GLOBAL_RNG</code>: The random number generator to use. The call <code>Random.rand(rng, N, N)</code> must produces a real-valued <span>$N×N$</span> matrix with elements uniformly distributed between 0 and 1</li></ul><p><strong>See also</strong></p><ul><li><a href="#QuantumControlTestUtils.RandomObjects.random_dynamic_generator-Tuple{Any, Any}"><code>random_dynamic_generator</code></a> — generate a time-dependent random</li></ul><p>Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlTestUtils.jl/blob/10524510f2ca7f2b26c219c4673538704fd13b1a/src/random.jl#L12-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlTestUtils.RandomObjects.random_state_vector-Tuple{Any}" href="#QuantumControlTestUtils.RandomObjects.random_state_vector-Tuple{Any}"><code>QuantumControlTestUtils.RandomObjects.random_state_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a random, normalized Hilbert space state vector of dimension <code>N</code>.</p><pre><code class="language-julia hljs">random_state_vector(N; rng=GLOBAL_RNG)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlTestUtils.jl/blob/10524510f2ca7f2b26c219c4673538704fd13b1a/src/random.jl#L438-L444">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlTestUtils.DummyOptimization.dummy_control_problem-Tuple{}" href="#QuantumControlTestUtils.DummyOptimization.dummy_control_problem-Tuple{}"><code>QuantumControlTestUtils.DummyOptimization.dummy_control_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set up a dummy control problem.</p><pre><code class="language-julia hljs">problem = dummy_control_problem(;
    N=10, n_objectives=1, n_controls=1, n_steps=50, dt=1.0, density=0.5,
    complex_operators=true, hermitian=true, pulses_as_controls=false, rng,
    kwargs...)</code></pre><p>Sets up a control problem with random (sparse) Hermitian matrices.</p><p><strong>Arguments</strong></p><ul><li><code>N</code>: The dimension of the Hilbert space</li><li><code>n_objectives</code>: The number of objectives in the optimization. All objectives will have the same Hamiltonian, but random initial and target states.</li><li><code>n_controls</code>: The number of controls, that is, the number of control terms in the control Hamiltonian. Each control is an array of random values, normalized on the intervals of the time grid.</li><li><code>n_steps</code>: The number of time steps (intervals of the time grid)</li><li><code>dt</code>: The time step</li><li><code>density</code>: The density of the Hamiltonians, as a number between 0.0 and 1.0. For <code>density=1.0</code>, the Hamiltonians will be dense matrices.</li><li><code>complex_operators</code>: Whether or not the drift/control operators will be complex-valued or real-valued.</li><li><code>hermitian</code>: Whether or not all drift/control operators will be Hermitian matrices.</li><li><code>pulses_as_controls=false</code>: If true, directly use pulses (discretized to the midpoints of the time grid) as controls, instead of the normal controls discretized to the points of the time grid.</li><li><code>rng=Random.GLOBAL_RNG</code>: The random number generator to use.  See <a href="#QuantumControlTestUtils.RandomObjects.random_matrix-Tuple{Any}"><code>random_matrix</code></a> and <a href="#QuantumControlTestUtils.RandomObjects.random_state_vector-Tuple{Any}"><code>random_state_vector</code></a>.</li><li><code>kwargs</code>: All other keyword arguments are passed on to <a href="@ref"><code>ControlProblem</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlTestUtils.jl/blob/10524510f2ca7f2b26c219c4673538704fd13b1a/src/dummy_problem.jl#L16-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumControlTestUtils.DummyOptimization.optimize_with_dummy_method-Tuple{Any}" href="#QuantumControlTestUtils.DummyOptimization.optimize_with_dummy_method-Tuple{Any}"><code>QuantumControlTestUtils.DummyOptimization.optimize_with_dummy_method</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Run a dummy optimization.</p><pre><code class="language-julia hljs">result = optimize(problem, method=:dummymethod)</code></pre><p>runs through and &quot;optimization&quot; of the given <code>problem</code> where in each iteration, the amplitude of the guess pulses is diminished by 10%. The (summed) vector norm of the the control serves as the value of the optimization functional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQuantumControl/QuantumControlTestUtils.jl/blob/10524510f2ca7f2b26c219c4673538704fd13b1a/src/dummy_problem.jl#L203-L213">source</a></section></article></article><nav class="docs-footer"><p class="footer-message"><a href="https://github.com/JuliaQuantumControl/QuantumControlTestUtils.jl">QuantumControlTestUtils.jl</a> v0.1.4+dev docs powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 5 April 2023 05:07">Wednesday 5 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
